# 11
## Binary Tree

A finite set of elements called node such that:
- $T$ is empty or
- $T$ contains a distinguished node $R$ called root of $T$ and the remaining nodes of $T$ form an ordered pair of disjoint binary trees $T_1$ and $T_2$.

**Successor:** child of a node.![[Screenshot 2025-10-13 at 11.52.47 AM.png|400]]

**Terminal Nodes:** leaf nodes of the tree. i.e. $D, F, G, L, K$.

- The term "**Similar**" is said if two binary tree $T$ and $T'$ have the same structure.
- The term "**Copies**" is said if two binary tree $T$ and $T'$ have the same contents at corresponding nodes.
![[Screenshot 2025-10-13 at 11.57.17 AM.png|400]]


![[Screenshot 2025-10-13 at 12.03.46 PM.png|300]]
- $N$ is called the parent of $S_1$ and $S_2$.
- $S_1$ is left child and $S_2$ is right child. They are said to be siblings.
- $N$ is descendant of $S_1$, $S_2$ and all of the node under them.
- $S_1$ and $S_2$ have one ancestor. i.e. $N$.
- The line between $N$ and $S_1$ is called edge.
- The sequence of consecutive edges is called a path.
- A terminal node is called leaf and a path ending in a lead is called a branch.

**Level Number:**
![[Screenshot 2025-10-13 at 12.12.47 PM.png|300]]
The depth of height of a tree $T$ is the maximum number nodes in a branch of $T$. i.e. here is $4$.

### Complete Binary Tree

The tree is said to be complete if:
- all its levels, except possibly the last, have the maximum number of possible nodes,
- all the nodes at the last level appear as far left possible.
**Level $r$ of $T$ can have at most $2^r$ nodes.**

![[Screenshot 2025-10-13 at 12.21.53 PM.png|400]]
Depth of the complete binary tree:
$$\text{Depth} = \lfloor log_2\ n + 1 \rfloor$$

### Binary Tree

A binary tree $T$ is said to be a $2-$tree or extended binary tree if each node $N$ has either $0$ or $2$ children.
- the nodes with $2$ children are called internal nodes.
- the nodes with $0$ children are called external nodes.
![[Screenshot 2025-10-13 at 12.27.59 PM.png|400]]

#### Representation of binary tree in memory

**Method - 01:**
- uses three parallel arrays: $\text{INFO, LEFT, RIGHT}$.
	- $\text{INFO[k]}$ contains the data at the node $N$.
	- $\text{LEFT[k]}$ contains the location of the left child of node $N$.
	- $\text{RIGHT[k]}$ contains the location of the right child of node $N$.
- A pointer variable $\text{ROOT}$.
![[Screenshot 2025-10-13 at 12.32.15 PM.png|400]]

**Method - 02:**
- uses only a single linear array $\text{TREE}$.
	- The root of $R$ of $T$ is stored in $\text{TREE[1]}$.
	- if a node $N$ occupies $\text{TREE[K]}$, then its left child is stored in $\text{TREE[2K]}$ and its right child is stored in $\text{TREE[2K+1]}$.
![[Screenshot 2025-10-13 at 12.36.01 PM.png|300]]

#### Traversing

- **Preorder:** $Root \rightarrow Left \rightarrow Right$.
- **Inorder:** $Left \rightarrow Root \rightarrow Right$.
- **Postorder:** $Left \rightarrow Right \rightarrow Root$.
```cpp
struct Node {
    char data;
    Node* left;
    Node* right;
};

// ðŸ”¹ Preorder Traversal (Root â†’ Left â†’ Right)
void preorder(Node* root) {
    if (root == nullptr) return;
    cout << root->data << " ";
    preorder(root->left);
    preorder(root->right);
}

// ðŸ”¹ Inorder Traversal (Left â†’ Root â†’ Right)
void inorder(Node* root) {
    if (root == nullptr) return;
    inorder(root->left);
    cout << root->data << " ";
    inorder(root->right);
}

// ðŸ”¹ Postorder Traversal (Left â†’ Right â†’ Root)
void postorder(Node* root) {
    if (root == nullptr) return;
    postorder(root->left);
    postorder(root->right);
    cout << root->data << " ";
}
```

#### Traversal Algorithm using Stacks
**Method - 01: (Preorder)**
- process the root.
- go to the left child and push the right child to the stack.
- when there is no left child, pop from the stack and process that until the stack is empty.

**Method - 02: (Inorder)**
- start from the root. push the root to the stack and go process left child until found $NULL$. Push the root and right child if they present.
- then pop from stack, then go right child and push this until fount the $NULL$.
- go this thing until found the stack is empty.

**Method - 03: (Postorder)**
- start from the root. Process the left child. Push the root and then push the right child as $-RIGHT[PTR]$. Do that until fount $NULL$.
- Pop from the stack until $PTR>0$. When found $PTR<0$, apply step-$01$. In this time when you push the root, it has negative, convert this to positive.
- do this thing until the stack is empty.

# 12
### Header Node: Threads
 
 A special node in a threaded binary tree that provides an easy way to start and end the traversal of the tree.

### Threaded Binary Tree

A binary tree with threads are called threaded tree.
- One-way threading
	- a thread will appear in the right field of a node
	- Example:
		![[Screenshot 2025-10-13 at 3.26.04 PM.png|400]]
- Two-way threading
	- threads will appear in both left and right fields.
	- Example:
		![[Screenshot 2025-10-13 at 3.27.27 PM.png|400]]
- Two-way threading with header node:
	- Example:
		![[Screenshot 2025-10-13 at 3.30.16 PM.png|400]]


## Binary Search Tree

A tree $T$ is called a binary search tree if each node $N$ of $T$ has the property:
- the value at $N$ is greater than every value in the left subtree of $N$.
- the value at $N$ is less than or equal to every value in the right subtree of $N$.

### Construction of BST

- start from left. the left-most element will be the root of the BST.
- then compare the next element with the root. If it larger or equal then go to the right-side. If smaller then go to the left-side.
- do this thing until a free position to place the element.

**Input:** $11,6,8,19,4,10,5,17,43,49,31$
![[Screenshot 2025-10-13 at 5.38.36 PM.png|400]]

### Insertion
Same as construction.

### Deletion

- **Case - 01:** (No child)
	- just remove that element.
- **Case - 02:** (1 child)
	- delete that element & connect that with the parent of that element.
- **Case - 03:** (2 child)
	- there are two ways:
		- Inorder predecessor --> sorting all element. then the prev element of that element. or max of left subtree.
		- Inorder successor --> sorting all element. then the next element of that element. or min of right subtree.

### Time Complexity
- **Searching:**
	- Best case + average case: $O(log\ n)$.
	- Worst case: $O(n)$.
- **Insertion:**
	- Best case + average case: $O(log\ n)$.
	- Worst case: $O(n)$.
- **Deletion:**
	- Best case + average case: $O(log\ n)$.
	- Worst case: $O(n)$.

### Construction of BST from Preorder and Inorder 

- **Preorder:** 1st is always root. $(ROOT \rightarrow LEFT \rightarrow RIGHT)$
- **Inorder:** root is in the middle. So, left side of the root is in the left subtree elements and right side of the root is in the right subtree elements. $(LEFT \rightarrow ROOT \rightarrow RIGHT)$.
- Example: 
		Preorder: $1,2,4,8,9,10,11,5,3,6,7$
		Inorder: $8,4,10,9,11,2,5,1,6,3,7$ 
	![[Screenshot 2025-10-13 at 10.24.51 PM.png|400]]

### Construction of BST from Preorder and Inorder 

- **Postorder:** last is the root. $(LEFT \rightarrow RIGHT \rightarrow ROOT)$.
- **Inorder:** root is in the middle. So, left side of the root is in the left subtree elements and right side of the root is in the right subtree elements. $(LEFT \rightarrow ROOT \rightarrow RIGHT)$.
- **Example:**
		Postorder: $9,1,2,12,7,5,3,11.4,8$
		Inorder: $9,5,1,7,2,12,8,4,3,11$ 
	![[Screenshot 2025-10-13 at 10.31.15 PM.png|400]]

# 13
## AVL Search Tree

An **AVL tree** is a **self-balancing binary search tree** where the height of the two child subtrees of any node differs by at most one.

**Disadvantage:** Worst case time complexity of a search is $O(n)$.

**Balance Factor (BF)** of a node in an **AVL Tree**:
$$\text{BalanceÂ FactorÂ (BF) = HeightÂ ofÂ LeftÂ Subtree âˆ’ HeightÂ ofÂ RightÂ Subtree}$$
- **It should be ${-1,0,1}$ for every node.**
### Rotation
- **LL Rotation:**
	![[Screenshot 2025-10-13 at 11.19.25 PM.png|400]]
- **RR Rotation:**
	![[Screenshot 2025-10-13 at 11.21.47 PM.png|400]]
- **LR Rotation:**
	![[Pasted image 20251013232723.png|400]]
- **RL Rotation:**
	![[Pasted image 20251013233258.png|400]]

### Construction of AVL Tree

- First go like BST. 
- Then check the balance factor of all node. If they are not ${-1,0,1}$, then apply rotation.
- Example: $14,17,11,7,53,4,13,12,8,60,19,16,20$
	![[Screenshot 2025-10-13 at 11.37.01 PM.png|500]]


### Insertion
- Same as construction

### Deletion
- same as BST.
- then check the balance factor and do rotation if needed.
- **Example:**
	![[Screenshot 2025-10-14 at 12.00.29 AM.png|500]]


## m-way Search Tree

pori nai ðŸ™‚

## B Tree

pori nai ðŸ™‚

## Heap

- Heap is a complete binary tree with $n$ element.
- **Maxheap** (each node $N$ of $H$ heap): The value at $N$ is greater than equal to the value at each of the children of $N$.
- **Minheap** (each node $N$ of $H$ heap): The value at $N$ is less than or equal to the value at each of the children of $N$.

### Insertion
- insert the element in the left-most position of the last level.
- then compare with the root. If root is smaller than that, swap them. Do this until the root is smaller.

### Deletion (Root)
- take the last element of the last level to the root.
- then compare the children with the root and swap them until that is the right position.

**Maintaining Heap is Heap Sort.**




