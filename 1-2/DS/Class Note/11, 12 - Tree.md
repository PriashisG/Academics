# 11
## Binary Tree

A finite set of elements called node such that:
- $T$ is empty or
- $T$ contains a distinguished node $R$ called root of $T$ and the remaining nodes of $T$ form an ordered pair of disjoint binary trees $T_1$ and $T_2$.

**Successor:** child of a node.![[Screenshot 2025-10-13 at 11.52.47 AM.png|400]]

**Terminal Nodes:** leaf nodes of the tree. i.e. $D, F, G, L, K$.

- The term "**Similar**" is said if two binary tree $T$ and $T'$ have the same structure.
- The term "**Copies**" is said if two binary tree $T$ and $T'$ have the same contents at corresponding nodes.
![[Screenshot 2025-10-13 at 11.57.17 AM.png|400]]


![[Screenshot 2025-10-13 at 12.03.46 PM.png|300]]
- $N$ is called the parent of $S_1$ and $S_2$.
- $S_1$ is left child and $S_2$ is right child. They are said to be siblings.
- $N$ is descendant of $S_1$, $S_2$ and all of the node under them.
- $S_1$ and $S_2$ have one ancestor. i.e. $N$.
- The line between $N$ and $S_1$ is called edge.
- The sequence of consecutive edges is called a path.
- A terminal node is called leaf and a path ending in a lead is called a branch.

**Level Number:**
![[Screenshot 2025-10-13 at 12.12.47 PM.png|300]]
The depth of height of a tree $T$ is the maximum number nodes in a branch of $T$. i.e. here is $4$.

### Complete Binary Tree

The tree is said to be complete if:
- all its levels, except possibly the last, have the maximum number of possible nodes,
- all the nodes at the last level appear as far left possible.
**Level $r$ of $T$ can have at most $2^r$ nodes.**

![[Screenshot 2025-10-13 at 12.21.53 PM.png|400]]
Depth of the complete binary tree:
$$\text{Depth} = \lfloor log_2\ n + 1 \rfloor$$

### Binary Tree

A binary tree $T$ is said to be a $2-$tree or extended binary tree if each node $N$ has either $0$ or $2$ children.
- the nodes with $2$ children are called internal nodes.
- the nodes with $0$ children are called external nodes.
![[Screenshot 2025-10-13 at 12.27.59 PM.png|400]]

#### Representation of binary tree in memory

**Method - 01:**
- uses three parallel arrays: $\text{INFO, LEFT, RIGHT}$.
	- $\text{INFO[k]}$ contains the data at the node $N$.
	- $\text{LEFT[k]}$ contains the location of the left child of node $N$.
	- $\text{RIGHT[k]}$ contains the location of the right child of node $N$.
- A pointer variable $\text{ROOT}$.
![[Screenshot 2025-10-13 at 12.32.15 PM.png|400]]

**Method - 02:**
- uses only a single linear array $\text{TREE}$.
	- The root of $R$ of $T$ is stored in $\text{TREE[1]}$.
	- if a node $N$ occupies $\text{TREE[K]}$, then its left child is stored in $\text{TREE[2K]}$ and its right child is stored in $\text{TREE[2K+1]}$.
![[Screenshot 2025-10-13 at 12.36.01 PM.png|300]]

#### Traversing

- **Preorder:** $Root \rightarrow Left \rightarrow Right$.
- **Inorder:** $Left \rightarrow Root \rightarrow Right$.
- **Postorder:** $Left \rightarrow Right \rightarrow Root$.
```cpp
struct Node {
    char data;
    Node* left;
    Node* right;
};

// ðŸ”¹ Preorder Traversal (Root â†’ Left â†’ Right)
void preorder(Node* root) {
    if (root == nullptr) return;
    cout << root->data << " ";
    preorder(root->left);
    preorder(root->right);
}

// ðŸ”¹ Inorder Traversal (Left â†’ Root â†’ Right)
void inorder(Node* root) {
    if (root == nullptr) return;
    inorder(root->left);
    cout << root->data << " ";
    inorder(root->right);
}

// ðŸ”¹ Postorder Traversal (Left â†’ Right â†’ Root)
void postorder(Node* root) {
    if (root == nullptr) return;
    postorder(root->left);
    postorder(root->right);
    cout << root->data << " ";
}
```

#### Traversal Algorithm using Stacks
**Method - 01: (Preorder)**
- process the root.
- go to the left child and push the right child to the stack.
- when there is no left child, pop from the stack and process that until the stack is empty.

**Method - 02: (Inorder)**
- start from the root. push the root to the stack and go process left child until found $NULL$. Push the root and right child if they present.
- then pop from stack, then go right child and push this until fount the $NULL$.
- go this thing until found the stack is empty.

**Method - 03: (Postorder)**
- start from the root. Process the left child. Push the root and then push the right child as $-RIGHT[PTR]$. Do that until fount $NULL$.
- Pop from the stack until $PTR>0$. When found $PTR<0$, apply step-$01$. In this time when you push the root, it has negative, convert this to positive.
- do this thing until the stack is empty.

# 12
### Header Node: Threads
 
 A special node in a threaded binary tree that provides an easy way to start and end the traversal of the tree.

### Threaded Binary Tree

A binary tree with threads are called threaded tree.
- One-way threading
	- a thread will appear in the right field of a node
	- Example:
		![[Screenshot 2025-10-13 at 3.26.04 PM.png|400]]
- Two-way threading
	- threads will appear in both left and right fields.
	- Example:
		![[Screenshot 2025-10-13 at 3.27.27 PM.png|400]]
- Two-way threading with header node:
	- Example:
		![[Screenshot 2025-10-13 at 3.30.16 PM.png|400]]


## Binary Search Tree

A tree $T$ is called a binary search tree if each node $N$ of $T$ has the property:
- the value at $N$ is greater than every value in the left subtree of $N$.
- the value at $N$ is less than or equal to every value in the right subtree of $N$.

